import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import User from "../models/models.js";

// const { mongooseToObject } = require("../../util/mongoose");

let otpStore = {};

class Controller {
  // ADMIN
  // GET /api/users
  async getAllUsers(req, res) {
    try {
      User.findOne({}).sort({ _id: "desc" });

      const users = await User.find().sort({ createdAt: -1 });

      res.status(200).json(users);
    } catch (err) {
      res.status(500).json({ message: "L·ªói server", error: err.message });
    }
  }

  //create /api/users
  async createUser(req, res) {
    try {
      const newUser = new User(req.body);
      await newUser.save();
      res.status(200).json(newUser);
    } catch (error) {
      res
        .status(500)
        .json({ message: "L·ªói khi t·∫°o user", error: error.massage });
    }
  }

  // delete /api/users
  async deleteUser(req, res) {
    try {
      const user = await User.findByIdAndDelete(req.params.id);

      if (!user) {
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y User" });
      }

      res.status(200).json({ message: "X√≥a th√†nh c√¥ng!" });
    } catch (error) {
      console.error("‚ùå L·ªói khi x√≥a user:", error);
      res
        .status(500)
        .json({ message: "L·ªói kh√¥ng th·ªÉ x√≥a!", error: error.message });
    }
  }

  // login
  async login(req, res) {
    try {
      const { identifier, password } = req.body;
      // search user email
      const user = await User.findOne({
        $or: [{ email: identifier }, { phone: identifier }],
      });
      if (!user) {
        return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" });
      }

      // compare birth password
      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch)
        return res.status(400).json({ message: "M·∫≠t kh·∫©u kh√¥ng t·ªìn t·∫°i!" });

      // create token

      // const header = {
      //   alg:"HS256",
      //   typ:"JWT",
      // };
      // const payload = {
      //   sub: user.id,
      //   exp: Date.now + 3600000,
      // }
      // const  encodeHeader = btoa(JSON.stringify(header));
      // const encodePayload = btoa(JSON.stringify(payload));

      // const tokenData = `${encodeHeader}.${encodePayload}`;
      // const hmac = crypto.createHmac()

      // end

      //  create token
      const token = jwt.sign(
        { id: user._id, email: user.email },
        process.env.JWT_SECRET || "secretkey",
        { expiresIn: "1d" }
      );

      res.json({ message: "ƒêƒÉng nh·∫≠p th√†nh c√¥ng", token, user });
    } catch (error) {
      res.status(500).json({ message: "L·ªói sever", error: error.message });
    }
  }

  // forget password
  async forgetPassword(req, res) {
    try {
      const { email, phone } = req.body;

      //search user
      const user = await User.findOne({ $or: [{ email }, { phone }] });
      if (!user)
        return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n!" });

      // create OTP
      const otp = Math.floor(100000 + Math.random() * 900000).toString();

      // saver otp
      otpStore[user._id] = { otp, expires: Date.now() + 5 * 60 * 1000 };

      //send otp
      if (email) {
        const transporter = nodemailer.createTransport({
          service: "gmail",
          auth: {
            user: process.env.EMAIL_USER,
            pass: process.env.EMAIL_PASS,
          },
        });
        await transporter.sendMail({
          from: process.env.EMAIL_USER,
          to: user.email,
          subject: "M√£ OTP kh√¥i ph·ª•c m·∫≠t kh·∫©u",
          text: `M√£ OTP c·ªßa b·∫°n l√†: ${otp}`,
        });
      }
      res.json({ message: "M√£ OTP ƒë√£ ƒë∆∞·ª£c g·ª≠i ƒë·∫øn email/s·ªë ƒëi·ªán tho·∫°i." });
    } catch (error) {
      res.status(500).json({ message: "L·ªói serve", error: error.message });
    }
  }

  // verifyOtp
  async verifyOtp(req, res) {
    const { userId, otp } = req.body;

    if (!otpStore[userId])
      return res
        .status(400)
        .json({ message: "OTP kh√¥ng t·ªìn t·∫°i ho·∫∑c ƒë√£ h·∫øt h·∫°n" });

    const { otp: storedOtp, expires } = otpStore[userId];

    if (Date.now() > expires)
      return res.status(400).json({ message: "OTP ƒë√£ h·∫øt h·∫°n" });
    if (otp !== storedOtp)
      return res.status(400).json({ message: "OTP kh√¥ng ƒë√∫ng" });

    // T·∫°o token cho ph√©p reset password
    const token = jwt.sign({ userId }, process.env.JWT_SECRET, {
      expiresIn: "10m",
    });

    res.json({ message: "X√°c minh th√†nh c√¥ng", token });
  }

  // reset password
  async resetPassword(req, res) {
    try {
      const { token, newPassword } = req.body;

      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      const user = await User.findById(decoded.userId);

      if (!user)
        return res.status(404).json({ message: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i" });

      user.password = await bcrypt.hash(newPassword, 10);
      await user.save();

      delete otpStore[user._id]; // X√≥a OTP c≈©

      res.json({ message: "ƒê·∫∑t l·∫°i m·∫≠t kh·∫©u th√†nh c√¥ng" });
    } catch (error) {
      res.status(500).json({ message: "L·ªói server", error: error.message });
    }
  }

  // register
  async register(req, res) {
    try {
      const { email, password, name, phone, configPassword } = req.body;

      // Ki·ªÉm tra m·∫≠t kh·∫©u nh·∫≠p l·∫°i
      if (password !== configPassword) {
        return res
          .status(400)
          .json({ message: "M·∫≠t kh·∫©u nh·∫≠p l·∫°i kh√¥ng kh·ªõp" });
      }

      //  Ki·ªÉm tra email t·ªìn t·∫°i
      const existEmail = await User.findOne({ email });
      if (existEmail)
        return res.status(400).json({ message: "Email ƒë√£ t·ªìn t·∫°i" });

      //  Ki·ªÉm tra s·ªë ƒëi·ªán tho·∫°i t·ªìn t·∫°i
      const existPhone = await User.findOne({ phone });
      if (existPhone)
        return res.status(400).json({ message: "S·ªë ƒëi·ªán tho·∫°i ƒë√£ t·ªìn t·∫°i" });

      // Hash password
      // const hashedPassword = await bcrypt.hash(password, 6);
      // T·∫°o user m·ªõi
      const user = new User({
        email,
        password,
        name,
        phone,
      });

      await user.save();

      //  create token
      const token = jwt.sign(
        { id: user._id, email: user.email },
        process.env.JWT_SECRET || "secretkey",
        { expiresIn: "1d" }
      );

      console.log(user);

      res.status(201).json({ message: "ƒêƒÉng k√Ω th√†nh c√¥ng", user, token });
    } catch (error) {
      res.status(500).json({ message: "L·ªói server", error: error.message });
    }
  }

  // addInformation
  async addInformation(req, res) {
    try {
      const {
        userId,
        nameUser,
        birdDay,
        website,
        gender,
        Address,
        careerGoal,
        action = "replace",
      } = req.body;

      // üü¢ parse m·∫£ng workExperiences (t·ª´ FormData -> string)
      let workExperiences = [];
      if (req.body.workExperiences) {
        try {
          workExperiences = JSON.parse(req.body.workExperiences);
        } catch (err) {
          console.error("Parse workExperiences l·ªói:", err);
        }
      }

      const user = await User.findById(userId);
      if (!user)
        return res.status(404).json({ massage: "Ng∆∞·ªùi d√πng kh√¥ng t·ªìn t·∫°i!" });

      // update
      user.nameUser = nameUser || user.nameUser;
      user.birdDay = birdDay || user.birdDay;
      user.website = website || user.website;
      user.gender = gender || user.gender;
      user.Address = Address || user.Address;
      user.careerGoal = careerGoal || user.careerGoal;

      // upload avatar (1 file)
      if (req.file) {
        user.avatar = req.file.path; // ƒë∆∞·ªùng d·∫´n file ·∫£nh
      }

      // ‚úÖ upload nhi·ªÅu file (n·∫øu c√≥)
      if (req.files && req.files.length > 0) {
        // V√≠ d·ª• b·∫°n l∆∞u t·∫•t c·∫£ file v√†o m·∫£ng user.attachments
        const newFiles = req.files.map((file) => ({
          filename: file.originalname,
          path: file.path,
          mimetype: file.mimetype,
        }));

        if (action === "append") {
          user.attachments = [...(user.attachments || []), ...newFiles];
        } else {
          user.attachments = newFiles;
        }
      }

      // object information
      if (workExperiences && workExperiences.length > 0) {
        // isArray
        const arr = Array.isArray(workExperiences)
          ? workExperiences
          : [workExperiences];

        // chu·∫©n h√≥a field ng√†y th√°ng
        const normalized = arr.map((exp) => ({
          company: exp.company,
          position: exp.position,
          startDate: exp.startDate ? new Date(exp.startDate) : null,
          endDate: exp.endDate ? new Date(exp.endDate) : null,
          description: exp.description,
          achievements: exp.achievements,
        }));

        if (action === "append") {
          user.workExperiences.push(...normalized);
        } else {
          user.workExperiences = normalized;
        }
      }

      await user.save();
      res.status(200).json({ message: "C·∫≠p nh·∫≠t th√†nh c√¥ng", user });
    } catch (error) {
      console.error(" Error addInformation:", error);
      res.status(500).json({ message: "L·ªói server", error: error.message });
    }
  }
}

export default new Controller();
